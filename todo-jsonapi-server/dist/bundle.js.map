{"version":3,"file":"bundle.js","sources":["../node_modules/lux-framework/src/utils/entries.js","../node_modules/lux-framework/src/packages/database/errors/model-missing-error.js","../node_modules/lux-framework/src/packages/jsonapi/utils/has-media-type.js","../node_modules/lux-framework/src/packages/database/errors/config-missing-error.js","../node_modules/lux-framework/src/packages/database/relationship/utils/unassociate.js","../node_modules/lux-framework/src/packages/database/relationship/utils/update-relationship.js","../node_modules/lux-framework/src/packages/database/attribute/utils/create-normalizer.js","../node_modules/lux-framework/src/packages/database/validation/errors/validation-error.js","../node_modules/lux-framework/src/packages/database/validation/index.js","../node_modules/lux-framework/src/packages/database/utils/create-migrations.js","../node_modules/lux-framework/src/packages/database/migration/index.js","../node_modules/lux-framework/src/errors/controller-missing-error.js","../config/database.js","../config/environments/development.js"],"sourcesContent":["// @flow\nconst HAS_OBJECT_ENTRIES = typeof Object.entries === 'function';\n\n/**\n * @private\n */\nexport default function entries(source: Object): Array<[string, any]> {\n  if (HAS_OBJECT_ENTRIES) {\n    return Object.entries(source);\n  }\n\n  return Object.keys(source).reduce((result, key) => {\n    const value = Reflect.get(source, key);\n\n    result.push([key, value]);\n\n    return result;\n  }, []);\n}\n","// @flow\n\n/**\n * @private\n */\nclass ModelMissingError extends Error {\n  constructor(name: string) {\n    super(`Could not resolve model by name '${name}'`);\n  }\n}\n\nexport default ModelMissingError;\n","// @flow\nconst PATTERN = /^application\\/vnd.api\\+json;charset=.+$/;\n\n/**\n * @private\n */\nexport default function hasMediaType(value: string): boolean {\n  return PATTERN.test(value);\n}\n","// @flow\nclass ConfigMissingError extends Error {\n  constructor(environment: string) {\n    super(`Database config not found for environment ${environment}.`);\n  }\n}\n\nexport default ConfigMissingError;\n","// @flow\nimport type { Model } from '../../index'; // eslint-disable-line no-unused-vars\n\n/**\n * @private\n */\nfunction unassociateOne<T: void | ?Model>(value: T, foreignKey: string): T {\n  if (value) {\n    Reflect.set(value, foreignKey, null);\n  }\n\n  return value;\n}\n\n/**\n * @private\n */\nexport default function unassociate<T: Model, U: Array<T>>(\n  value: U,\n  foreignKey: string\n): U | Array<T> {\n  return value.map(record => unassociateOne(record, foreignKey));\n}\n","// @flow\nimport type { Model } from '../../index';\nimport type { Relationship$opts } from '../interfaces';\n\ntype Params = {\n  record: Model;\n  value: ?Model | Array<Model>;\n  opts: Relationship$opts;\n  trx: Object;\n};\n\nfunction updateHasOne({\n  record,\n  value,\n  opts,\n  trx\n}: Params): Array<Object> {\n  const recordPrimaryKey = record.getPrimaryKey();\n\n  if (value) {\n    if (value instanceof opts.model) {\n      return [\n        opts.model\n          .table()\n          .transacting(trx)\n          .update(opts.foreignKey, null)\n          .where(\n            `${opts.model.tableName}.${opts.foreignKey}`,\n            recordPrimaryKey\n          )\n          .whereNot(\n            `${opts.model.tableName}.${opts.model.primaryKey}`,\n            value.getPrimaryKey()\n          ),\n        opts.model\n          .table()\n          .transacting(trx)\n          .update(opts.foreignKey, recordPrimaryKey)\n          .where(\n            `${opts.model.tableName}.${opts.model.primaryKey}`,\n            value.getPrimaryKey()\n          )\n      ];\n    }\n  } else {\n    return [\n      opts.model\n        .table()\n        .transacting(trx)\n        .update(opts.foreignKey, null)\n        .where(\n          `${opts.model.tableName}.${opts.foreignKey}`,\n          recordPrimaryKey\n        )\n    ];\n  }\n\n  return [];\n}\n\nfunction updateHasMany({\n  record,\n  value,\n  opts,\n  trx\n}: Params): Array<Object> {\n  const recordPrimaryKey = record.getPrimaryKey();\n\n  if (Array.isArray(value) && value.length) {\n    return [\n      opts.model\n        .table()\n        .transacting(trx)\n        .update(opts.foreignKey, null)\n        .where(\n          `${opts.model.tableName}.${opts.foreignKey}`,\n          recordPrimaryKey\n        )\n        .whereNotIn(\n          `${opts.model.tableName}.${opts.model.primaryKey}`,\n          value.map(item => item.getPrimaryKey())\n        ),\n      opts.model\n        .table()\n        .transacting(trx)\n        .update(opts.foreignKey, recordPrimaryKey)\n        .whereIn(\n          `${opts.model.tableName}.${opts.model.primaryKey}`,\n          value.map(item => item.getPrimaryKey())\n        )\n    ];\n  }\n\n  return [\n    opts.model\n      .table()\n      .transacting(trx)\n      .update(opts.foreignKey, null)\n      .where(\n        `${opts.model.tableName}.${opts.foreignKey}`,\n        recordPrimaryKey\n      )\n  ];\n}\n\nfunction updateBelongsTo({\n  record,\n  value,\n  opts,\n  trx\n}: Params): Array<Object> {\n  if (value instanceof opts.model) {\n    const inverseOpts = opts.model.relationshipFor(opts.inverse);\n    const foreignKeyValue = value.getPrimaryKey();\n\n    Reflect.set(record, opts.foreignKey, foreignKeyValue);\n\n    if (inverseOpts && inverseOpts.type === 'hasOne') {\n      return [\n        record.constructor\n          .table()\n          .transacting(trx)\n          .update(opts.foreignKey, null)\n          .where(opts.foreignKey, foreignKeyValue)\n          .whereNot(\n            `${record.constructor.tableName}.${record.constructor.primaryKey}`,\n            record.getPrimaryKey()\n          )\n      ];\n    }\n  }\n\n  return [];\n}\n\n/**\n * @private\n */\nexport default function updateRelationship(\n  record: Model,\n  name: string,\n  trx: Object\n): Array<Object> {\n  const opts = record.constructor.relationshipFor(name);\n\n  if (!opts) {\n    const {\n      constructor: {\n        name: className\n      }\n    } = record;\n\n    throw new Error(`Could not find relationship '${name} on '${className}`);\n  }\n\n  const { dirtyRelationships } = record;\n\n  if (!dirtyRelationships.has(name)) {\n    return [];\n  }\n\n  const value = dirtyRelationships.get(name);\n\n  switch (opts.type) {\n    case 'hasOne':\n      return updateHasOne({\n        record,\n        value,\n        opts,\n        trx\n      });\n\n    case 'hasMany':\n      return updateHasMany({\n        record,\n        value,\n        opts,\n        trx\n      });\n\n    default:\n      return updateBelongsTo({\n        record,\n        value,\n        opts,\n        trx\n      });\n  }\n}\n","// @flow\nconst BOOLEAN_TYPE = /^(?:boolean|tinyint)$/;\n\nexport default function createNormalizer(type: string): (value: any) => any {\n  let normalizer = value => value;\n\n  if (BOOLEAN_TYPE.test(type)) {\n    normalizer = value => {\n      let normalized = value;\n\n      if (typeof value === 'string') {\n        normalized = Number.parseInt(value, 10);\n      }\n\n      return Boolean(normalized);\n    };\n  } else if (type === 'datetime') {\n    normalizer = value => {\n      let normalized = value;\n\n      if (typeof value === 'number') {\n        normalized = new Date(normalized);\n      }\n\n      return normalized;\n    };\n  }\n\n  return normalizer;\n}\n","// @flow\n\n/**\n * @private\n */\nclass ValidationError extends Error {\n  constructor(key: string, value: string) {\n    super(`Validation failed for ${key}: ${value}`);\n  }\n}\n\nexport default ValidationError;\n","// @flow\nimport type { Validation$opts } from './interfaces';\n\n/**\n * @private\n */\nclass Validation<T> {\n  key: string;\n\n  value: T;\n\n  validator: (value?: T) => boolean;\n\n  constructor(opts: Validation$opts<T>) {\n    Object.defineProperties(this, {\n      key: {\n        value: opts.key,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      },\n\n      value: {\n        value: opts.value,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      },\n\n      validator: {\n        value: opts.validator,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      }\n    });\n  }\n\n  isValid(): boolean {\n    return this.validator(this.value);\n  }\n}\n\nexport default Validation;\nexport { ValidationError } from './errors';\n","// @flow\nimport type Database from '../index';\n\n/**\n * @private\n */\nexport default async function createMigrations(\n  schema: $PropertyType<Database, 'schema'>\n): Promise<boolean> {\n  const hasTable: boolean = await schema().hasTable('migrations');\n\n  if (!hasTable) {\n    await schema().createTable('migrations', table => {\n      table.string('version', 16).primary();\n    });\n  }\n\n  return true;\n}\n","// @flow\nimport type { Migration$Fn } from './interfaces';\n\n/**\n * @private\n */\nclass Migration<T: Object> {\n  fn: Migration$Fn<T>;\n\n  constructor(fn: Migration$Fn<T>) {\n    this.fn = fn;\n  }\n\n  run(schema: T): T {\n    return this.fn(schema);\n  }\n}\n\nexport default Migration;\nexport { default as generateTimestamp } from './utils/generate-timestamp';\nexport type { Migration$Fn } from './interfaces';\n","// @flow\n\n/**\n * @private\n */\nclass ControllerMissingError extends ReferenceError {\n  constructor(resource: string) {\n    super(`Could not resolve controller by name '${resource}'`);\n  }\n}\n\nexport default ControllerMissingError;\n","export default {\n  development: {\n    driver: 'sqlite3',\n    database: 'todo_dev'\n  },\n\n  test: {\n    driver: 'sqlite3',\n    database: 'todo_test'\n  },\n\n  production: {\n    driver: 'sqlite3',\n    database: 'todo_prod'\n  }\n};","export default {\n  server: {\n    cors: {\n      origin: '*',\n      enabled: true,\n\n      headers: ['Accept', 'Content-Type'],\n\n      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']\n    }\n  },\n  logging: {\n    level: 'DEBUG',\n    format: 'text',\n    enabled: true,\n\n    filter: {\n      params: []\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACKA;;;;;;;;ACKA;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;;;;;;;;;;;;;;;;ACIA;;ACCA;;;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}